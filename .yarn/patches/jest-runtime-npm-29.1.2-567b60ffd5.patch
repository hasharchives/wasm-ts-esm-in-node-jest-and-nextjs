diff --git a/build/index.js b/build/index.js
index 30d7657b066f12b1002f5d802a367c50e9819d79..4cba43bfb7d5d2f1c2a3aafdb1e58e265f6aea79 100644
--- a/build/index.js
+++ b/build/index.js
@@ -496,7 +496,7 @@ class Runtime {
   } // unstable as it should be replaced by https://github.com/nodejs/modules/issues/393, and we don't want people to use it
 
   unstable_shouldLoadAsEsm(path) {
-    return _jestResolve().default.unstable_shouldLoadAsEsm(
+    return path.endsWith('wasm') || _jestResolve().default.unstable_shouldLoadAsEsm(
       path,
       this._config.extensionsToTreatAsEsm
     );
@@ -534,6 +534,16 @@ class Runtime {
         'Promise initialization should be sync - please report this bug to Jest!'
       );
 
+      if (modulePath.endsWith('wasm')) {
+        const wasm = this._importWasmModule(modulePath, context);
+
+        this._esmoduleRegistry.set(cacheKey, wasm);
+
+        transformResolve();
+        return wasm;
+        
+      }
+      
       if (this._resolver.isCoreModule(modulePath)) {
         const core = this._importCoreModule(modulePath, context);
 
@@ -1716,6 +1726,39 @@ class Runtime {
     return require(moduleWithoutNodePrefix);
   }
 
+  async _importWasmModule(moduleName, context) {
+    const wasmModule = await WebAssembly.compile(fs().readFileSync(moduleName));
+
+    const exports = WebAssembly.Module.exports(wasmModule);
+    const imports = WebAssembly.Module.imports(wasmModule);
+    
+    const moduleLookup = {};
+    for (const { module } of imports) {
+      if (moduleLookup[module] === undefined) {
+        moduleLookup[module] = await this.linkAndEvaluateModule(await this.resolveModule(module, moduleName, context))
+      }
+    }
+
+    const syntheticModule = new (_vm().SyntheticModule)(exports.map(({ name }) => name), function() {
+      const importsObject = {};
+      for (const { module, name } of imports) {
+        if (!importsObject[module]) {
+          importsObject[module] = {}
+        }
+        importsObject[module][name] = moduleLookup[module].namespace[name];
+      }
+      const wasmInstance = new WebAssembly.Instance(wasmModule, importsObject);
+      for (const { name } of exports) {
+        this.setExport(name, wasmInstance.exports[name]);
+      }
+    }, {
+      context,
+      identifier: moduleName
+    });
+
+    return syntheticModule;
+  }
+  
   _importCoreModule(moduleName, context) {
     const required = this._requireCoreModule(moduleName, true);
 
